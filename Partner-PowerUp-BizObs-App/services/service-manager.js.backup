import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import http from 'http';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Track running child services and their context
const childServices = {};
const childServiceMeta = {};

// NEW: Complete service registry approach
const serviceRegistry = new Map(); // serviceName -> { port, process, status, meta }
const portRange = { min: 4101, max: 4299 };

// Initialize the service registry and find all available ports
function initializeServiceRegistry() {
  console.log('[service-manager] Initializing service registry...');
  // Clear any existing registry
  serviceRegistry.clear();
  console.log(`[service-manager] Service registry initialized with port range ${portRange.min}-${portRange.max}`);
}

// Get next available port (simple but reliable)
function getNextAvailablePort() {
  const usedPorts = new Set();
  
  // Collect all currently allocated ports
  for (const [serviceName, serviceInfo] of serviceRegistry) {
    if (serviceInfo.port && serviceInfo.status === 'running') {
      usedPorts.add(serviceInfo.port);
    }
  }
  
  // Find first available port
  for (let port = portRange.min; port <= portRange.max; port++) {
    if (!usedPorts.has(port)) {
      return port;
    }
  }
  
  throw new Error('No available ports in range');
}

// Register a service in the registry
function registerService(serviceName, port, process, meta) {
  serviceRegistry.set(serviceName, {
    port,
    process,
    status: 'starting',
    meta,
    startTime: Date.now()
  });
  console.log(`[service-manager] Registered service ${serviceName} on port ${port}`);
}

// Update service status
function updateServiceStatus(serviceName, status) {
  const serviceInfo = serviceRegistry.get(serviceName);
  if (serviceInfo) {
    serviceInfo.status = status;
    console.log(`[service-manager] Service ${serviceName} status updated to: ${status}`);
  }
}

// Unregister a service
function unregisterService(serviceName) {
  const serviceInfo = serviceRegistry.get(serviceName);
  if (serviceInfo) {
    console.log(`[service-manager] Unregistering service ${serviceName} from port ${serviceInfo.port}`);
    serviceRegistry.delete(serviceName);
    
    // Also clean up old tracking objects for compatibility
    delete childServices[serviceName];
    delete childServiceMeta[serviceName];
  }
}

// Get service port (NEW implementation)
export function getServicePort(stepName) {
  const serviceName = getServiceNameFromStep(stepName);
  if (!serviceName) return null;
  
  const serviceInfo = serviceRegistry.get(serviceName);
  if (serviceInfo && serviceInfo.status === 'running') {
    console.log(`[service-manager] Service "${serviceName}" already allocated to port ${serviceInfo.port}`);
    return serviceInfo.port;
  }
  
  // Allocate new port
  try {
    const port = getNextAvailablePort();
    console.log(`[service-manager] Allocated port ${port} for service "${serviceName}"`);
    return port;
  } catch (error) {
    console.error(`[service-manager] Failed to allocate port for ${serviceName}: ${error.message}`);
    return null;
  }
}

// Initialize the service registry on startup
initializeServiceRegistry();

// Check if a service port is ready to accept connections
export async function isServiceReady(port, timeout = 5000) {
  return new Promise((resolve) => {
    const start = Date.now();
    
    function checkPort() {
      const req = http.request({
        hostname: '127.0.0.1',
        port: port,
        path: '/health',
        method: 'GET',
        timeout: 1000
      }, (res) => {
        resolve(true);
      });
      
      req.on('error', () => {
        if (Date.now() - start < timeout) {
          setTimeout(checkPort, 200);
        } else {
          resolve(false);
        }
      });
      
      req.on('timeout', () => {
        req.destroy();
        if (Date.now() - start < timeout) {
          setTimeout(checkPort, 200);
        } else {
          resolve(false);
        }
      });
      
      req.end();
    }
    
    checkPort();
  });
}

// Convert step name to service format with enhanced dynamic generation
export function getServiceNameFromStep(stepName, context = {}) {
  if (!stepName) return null;
  
  // If already a proper service name, keep it
  if (/Service$|API$|Processor$|Manager$|Gateway$/.test(String(stepName))) {
    return String(stepName);
  }
  
  // Extract context information for more intelligent naming
  const description = context.description || '';
  const category = context.category || context.type || '';
  
  // Determine service suffix based on context
  let serviceSuffix = 'Service'; // default
  
  if (description.toLowerCase().includes('api') || context.endpoint) {
    serviceSuffix = 'API';
  } else if (description.toLowerCase().includes('process') || description.toLowerCase().includes('handle')) {
    serviceSuffix = 'Processor';
  } else if (description.toLowerCase().includes('manage') || description.toLowerCase().includes('control')) {
    serviceSuffix = 'Manager';
  } else if (description.toLowerCase().includes('gateway') || description.toLowerCase().includes('proxy')) {
    serviceSuffix = 'Gateway';
  } else if (category && !category.toLowerCase().includes('step')) {
    // Use category as suffix if it's meaningful
    serviceSuffix = category.charAt(0).toUpperCase() + category.slice(1) + 'Service';
  }
  
  // Normalize: handle spaces, underscores, hyphens, and existing CamelCase
  const cleaned = String(stepName).replace(/[^a-zA-Z0-9_\-\s]/g, '').trim();
  // Insert spaces between camelCase boundaries to preserve capitalization
  const spaced = cleaned
    // Replace underscores/hyphens with space
    .replace(/[\-_]+/g, ' ')
    // Split CamelCase: FooBar -> Foo Bar
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
    // Collapse multiple spaces
    .replace(/\s+/g, ' ')
    .trim();
  const serviceBase = spaced
    .split(' ')
    .filter(Boolean)
    .map(w => w.charAt(0).toUpperCase() + w.slice(1))
    .join('');
  
  const serviceName = `${serviceBase}${serviceSuffix}`;
  console.log(`[service-manager] Converting step "${stepName}" to dynamic service "${serviceName}" (context: ${JSON.stringify(context)})`);
  return serviceName;
}

// Get port for service using improved allocation strategy
export function getServicePort(stepName) {
  const serviceName = getServiceNameFromStep(stepName);
  if (!serviceName) return null;
  
  // Check if service already has a port allocated
  if (portAllocations.has(serviceName)) {
    const existingPort = portAllocations.get(serviceName);
    console.log(`[service-manager] Service "${serviceName}" already allocated to port ${existingPort}`);
    return existingPort;
  }
  
  // For high availability, use a round-robin approach with fallback
  let port = null;
  
  // First, try to get a port from the available pool
  if (portPool.size > 0) {
    // Convert set to array and get first available port
    const availablePorts = Array.from(portPool);
    port = availablePorts[0];
    portPool.delete(port);
    portAllocations.set(serviceName, port);
    console.log(`[service-manager] Service "${serviceName}" allocated port ${port} from pool (${portPool.size} remaining)`);
    return port;
  }
  
  // If pool is empty, try to find any unused port in range
  for (let p = portRange.min; p <= portRange.max; p++) {
    const portInUse = Array.from(portAllocations.values()).includes(p);
    if (!portInUse) {
      portAllocations.set(serviceName, p);
      console.log(`[service-manager] Service "${serviceName}" allocated fallback port ${p}`);
      return p;
    }
  }
  
  // If all ports are taken, force cleanup of dead services and retry
  console.warn(`[service-manager] All ports exhausted, attempting cleanup for service "${serviceName}"`);
  cleanupDeadServices();
  
  // Try again after cleanup
  if (portPool.size > 0) {
    const availablePorts = Array.from(portPool);
    port = availablePorts[0];
    portPool.delete(port);
    portAllocations.set(serviceName, port);
    console.log(`[service-manager] Service "${serviceName}" allocated port ${port} after cleanup`);
    return port;
  }
  
  console.error(`[service-manager] No available ports for service "${serviceName}" even after cleanup`);
  return null;
}

// Cleanup dead services and free their ports
function cleanupDeadServices() {
  const deadServices = [];
  
  for (const [serviceName, child] of Object.entries(childServices)) {
    if (child.killed || child.exitCode !== null) {
      deadServices.push(serviceName);
    }
  }
  
  deadServices.forEach(serviceName => {
    console.log(`[service-manager] Cleaning up dead service: ${serviceName}`);
    delete childServices[serviceName];
    delete childServiceMeta[serviceName];
    
    // Free the port allocation
    if (portAllocations.has(serviceName)) {
      const port = portAllocations.get(serviceName);
      portAllocations.delete(serviceName);
      portPool.add(port);
      console.log(`[service-manager] Freed port ${port} from dead service ${serviceName}`);
    }
  });
  
  console.log(`[service-manager] Cleanup completed: ${deadServices.length} dead services removed, ${portPool.size} ports available`);
}

// Start child service process
export function startChildService(serviceName, scriptPath, env = {}) {
  // Use the original step name from env, not derived from service name
  const stepName = env.STEP_NAME;
  if (!stepName) {
    console.error(`[service-manager] No STEP_NAME provided for service ${serviceName}`);
    return null;
  }
  
  // Extract company context for tagging
  const companyName = env.COMPANY_NAME || 'DefaultCompany';
  const domain = env.DOMAIN || 'default.com';
  const industryType = env.INDUSTRY_TYPE || 'general';
  
  const port = getServicePort(stepName);
  console.log(`ðŸš€ Starting child service: ${serviceName} on port ${port} for company: ${companyName} (domain: ${domain}, industry: ${industryType})`);
  
  const child = spawn('node', [scriptPath, '--service-name', serviceName], {
    env: { 
      ...process.env, 
      SERVICE_NAME: serviceName, 
      PORT: port,
      MAIN_SERVER_PORT: process.env.PORT || '4000',
      // Core company context for Dynatrace filtering
      COMPANY_NAME: companyName,
      DOMAIN: domain, 
      INDUSTRY_TYPE: industryType,
      // Plain env vars often captured by Dynatrace as [Environment] tags
      company: companyName,
      COMPANY: companyName,
      app: 'BizObs-CustomerJourney',
      APP: 'BizObs-CustomerJourney',
      service: serviceName,
      SERVICE: serviceName,
      // Dynatrace service identification
      DT_SERVICE_NAME: serviceName,
      DYNATRACE_SERVICE_NAME: serviceName,
      DT_LOGICAL_SERVICE_NAME: serviceName,
      // Process group identification
      DT_PROCESS_GROUP_NAME: serviceName,
      DT_PROCESS_GROUP_INSTANCE: `${serviceName}-${port}`,
      // Application context
      DT_APPLICATION_NAME: 'BizObs-CustomerJourney',
      DT_CLUSTER_ID: serviceName,
      DT_NODE_ID: `${serviceName}-node`,
      // Dynatrace tags - space separated for proper tag parsing
      DT_TAGS: `company=${companyName} app=BizObs-CustomerJourney service=${serviceName}`,
      // Optional custom props (many environments ignore these; kept for completeness)
      DT_CUSTOM_PROP: `company=${companyName};app=BizObs-CustomerJourney;service=${serviceName};domain=${domain};industryType=${industryType};service_type=customer_journey_step`,
      ...env 
    },
    stdio: ['ignore', 'pipe', 'pipe']
  });
  
  child.stdout.on('data', d => console.log(`[${serviceName}] ${d.toString().trim()}`));
  child.stderr.on('data', d => console.error(`[${serviceName}][ERR] ${d.toString().trim()}`));
  child.on('exit', code => {
    console.log(`[${serviceName}] exited with code ${code}`);
    delete childServices[serviceName];
    delete childServiceMeta[serviceName];
    // Free up the port allocation and return to pool
    if (portAllocations.has(serviceName)) {
      const port = portAllocations.get(serviceName);
      portAllocations.delete(serviceName);
      portPool.add(port);
      console.log(`[service-manager] Freed port ${port} for service ${serviceName}, returned to pool (${portPool.size} available)`);
    }
  });
  
  // Track startup time and metadata
  child.startTime = new Date().toISOString();
  childServices[serviceName] = child;
  // Record metadata for future context checks
  childServiceMeta[serviceName] = { 
    companyName, 
    domain, 
    industryType, 
    startTime: child.startTime,
    port 
  };
  return child;
}

// Function to start services dynamically based on journey steps
export async function ensureServiceRunning(stepName, companyContext = {}) {
  console.log(`[service-manager] ensureServiceRunning called for step: ${stepName}`);
  
  // Use exact serviceName from payload if provided, otherwise auto-generate with context
  const stepContext = {
    description: companyContext.description || '',
    category: companyContext.category || companyContext.type || '',
    endpoint: companyContext.endpoint
  };
  
  const serviceName = companyContext.serviceName || getServiceNameFromStep(stepName, stepContext);
  console.log(`[service-manager] Dynamic service name: ${serviceName}`);
  
  // FIRST: Check if service already exists and is running
  const existing = childServices[serviceName];
  if (existing) {
    console.log(`[service-manager] Service ${serviceName} already running, returning existing instance`);
    return existing;
  }
  
  // Check if another thread is already starting this service
  if (serviceStartupLocks.has(serviceName)) {
    console.log(`[service-manager] Service ${serviceName} is already being started, waiting...`);
    await serviceStartupLocks.get(serviceName);
    // After waiting, check if the service is now available
    if (childServices[serviceName]) {
      console.log(`[service-manager] Service ${serviceName} is now available after waiting`);
      return childServices[serviceName];
    }
  }
  
  // Extract company context with defaults
  const companyName = companyContext.companyName || 'DefaultCompany';
  const domain = companyContext.domain || 'default.com';
  const industryType = companyContext.industryType || 'general';
  const stepEnvName = companyContext.stepName || stepName;
  
  const desiredMeta = {
    companyName,
    domain,
    industryType
  };

  // Create a startup lock promise
  let lockResolve;
  const lockPromise = new Promise(resolve => {
    lockResolve = resolve;
  });
  serviceStartupLocks.set(serviceName, lockPromise);

  try {
    console.log(`[service-manager] Service ${serviceName} not running, starting it for company: ${companyName}...`);
    // Try to start with existing service file, fallback to dynamic service
    const specificServicePath = path.join(__dirname, `${serviceName}.cjs`);
    const dynamicServicePath = path.join(__dirname, 'dynamic-step-service.cjs');
    // Create a per-service wrapper so the Node entrypoint filename matches the service name
    const runnersDir = path.join(__dirname, '.dynamic-runners');
    const wrapperPath = path.join(runnersDir, `${serviceName}.cjs`);
    try {
      // Check if specific service exists
      if (fs.existsSync(specificServicePath)) {
        console.log(`[service-manager] Starting specific service: ${specificServicePath}`);
        startChildService(serviceName, specificServicePath, { 
          STEP_NAME: stepEnvName,
          COMPANY_NAME: companyName,
          DOMAIN: domain,
          INDUSTRY_TYPE: industryType
        });
        
        // Wait for the service to be ready
        console.log(`[service-manager] Waiting for specific service ${serviceName} to be ready...`);
        const meta = childServiceMeta[serviceName];
        if (meta && meta.port) {
          const isReady = await isServiceReady(meta.port, 10000);
          if (!isReady) {
            console.error(`[service-manager] Specific service ${serviceName} failed to become ready within timeout`);
            throw new Error(`Specific service ${serviceName} failed to start properly`);
          } else {
            console.log(`[service-manager] Specific service ${serviceName} is ready on port ${meta.port}`);
          }
        }
      } else {
        // Ensure runners directory exists
        if (!fs.existsSync(runnersDir)) {
          fs.mkdirSync(runnersDir, { recursive: true });
        }
        // Create/overwrite wrapper with service-specific entrypoint
        const wrapperSource = `// Auto-generated wrapper for ${serviceName}\n` +
`process.env.SERVICE_NAME = ${JSON.stringify(serviceName)};\n` +
`process.env.STEP_NAME = ${JSON.stringify(stepEnvName)};\n` +
`process.title = process.env.SERVICE_NAME;\n` +
`// Company context for tagging\n` +
`process.env.COMPANY_NAME = process.env.COMPANY_NAME || 'DefaultCompany';\n` +
`process.env.DOMAIN = process.env.DOMAIN || 'default.com';\n` +
`process.env.INDUSTRY_TYPE = process.env.INDUSTRY_TYPE || 'general';\n` +
`// Plain env tags often picked as [Environment] in Dynatrace\n` +
`process.env.company = process.env.COMPANY_NAME;\n` +
`process.env.app = 'BizObs-CustomerJourney';\n` +
`process.env.service = process.env.SERVICE_NAME;\n` +
`// Dynatrace service detection\n` +
`process.env.DT_SERVICE_NAME = process.env.SERVICE_NAME;\n` +
`process.env.DYNATRACE_SERVICE_NAME = process.env.SERVICE_NAME;\n` +
`process.env.DT_LOGICAL_SERVICE_NAME = process.env.SERVICE_NAME;\n` +
`process.env.DT_PROCESS_GROUP_NAME = process.env.SERVICE_NAME;\n` +
`process.env.DT_PROCESS_GROUP_INSTANCE = process.env.SERVICE_NAME + '-' + (process.env.PORT || '');\n` +
`process.env.DT_APPLICATION_NAME = 'BizObs-CustomerJourney';\n` +
`process.env.DT_CLUSTER_ID = process.env.SERVICE_NAME;\n` +
`process.env.DT_NODE_ID = process.env.SERVICE_NAME + '-node';\n` +
`// Dynatrace simplified tags - space separated for proper parsing\n` +
`process.env.DT_TAGS = 'company=' + process.env.COMPANY_NAME + ' app=BizObs-CustomerJourney service=' + process.env.SERVICE_NAME;\n` +
`// Optional aggregate custom prop\n` +
`process.env.DT_CUSTOM_PROP = 'company=' + process.env.COMPANY_NAME + ';app=BizObs-CustomerJourney;service=' + process.env.SERVICE_NAME + ';domain=' + process.env.DOMAIN + ';industryType=' + process.env.INDUSTRY_TYPE + ';service_type=customer_journey_step';\n` +
`// Override argv[0] for Dynatrace process detection\n` +
`if (process.argv && process.argv.length > 0) process.argv[0] = process.env.SERVICE_NAME;\n` +
`require(${JSON.stringify(dynamicServicePath)}).createStepService(process.env.SERVICE_NAME, process.env.STEP_NAME);\n`;
        fs.writeFileSync(wrapperPath, wrapperSource, 'utf-8');
        console.log(`[service-manager] Starting dynamic service via wrapper: ${wrapperPath}`);
        startChildService(serviceName, wrapperPath, { 
          STEP_NAME: stepEnvName,
          COMPANY_NAME: companyName,
          DOMAIN: domain,
          INDUSTRY_TYPE: industryType
        });
      }
      
      // Wait for the newly started service to be ready
      console.log(`[service-manager] Waiting for service ${serviceName} to be ready...`);
      const meta = childServiceMeta[serviceName];
      if (meta && meta.port) {
        const isReady = await isServiceReady(meta.port, 10000); // Wait up to 10 seconds
        if (!isReady) {
          console.error(`[service-manager] Service ${serviceName} failed to become ready within timeout`);
          throw new Error(`Service ${serviceName} failed to start properly`);
        } else {
          console.log(`[service-manager] Service ${serviceName} is ready on port ${meta.port}`);
        }
      }
    } catch (e) {
      console.error(`[service-manager] Failed to start service for step ${stepName}:`, e.message);
      throw e;
    } finally {
      // Release the startup lock
      serviceStartupLocks.delete(serviceName);
      if (lockResolve) lockResolve();
    }
  
    return childServices[serviceName];
  } catch (error) {
    // Release lock on error
    serviceStartupLocks.delete(serviceName);
    if (lockResolve) lockResolve();
    throw error;
  }
}

// Get all running services
export function getChildServices() {
  return childServices;
}

// Get service metadata
export function getChildServiceMeta() {
  return childServiceMeta;
}

// Stop all services and free all ports
export function stopAllServices() {
  Object.values(childServices).forEach(child => {
    child.kill('SIGTERM');
  });
  
  // Clear all allocations and reset port pool
  portAllocations.clear();
  portPool.clear();
  initializePortPool();
  console.log(`[service-manager] All services stopped, port pool reset (${portPool.size} ports available)`);
}

// Convenience helper: ensure a service is started and ready (health endpoint responding)
export async function ensureServiceReadyForStep(stepName, companyContext = {}, timeoutMs = 8000) {
  // Start if not running
  ensureServiceRunning(stepName, companyContext);
  const port = getServicePort(stepName);
  const start = Date.now();
  while (true) {
    const ready = await isServiceReady(port, 1000);
    if (ready) return port;
    if (Date.now() - start > timeoutMs) {
      throw new Error(`Service for step ${stepName} not ready on port ${port} within ${timeoutMs}ms`);
    }
    // Nudge start in case child crashed
    ensureServiceRunning(stepName, companyContext);
  }
}

// Health monitoring function to detect and resolve port conflicts
export async function performHealthCheck() {
  const healthResults = {
    totalServices: Object.keys(childServices).length,
    healthyServices: 0,
    unhealthyServices: 0,
    portConflicts: 0,
    availablePorts: portPool.size,
    issues: []
  };
  
  for (const [serviceName, child] of Object.entries(childServices)) {
    const meta = childServiceMeta[serviceName];
    if (!meta || !meta.port) {
      healthResults.issues.push(`Service ${serviceName} has no port metadata`);
      continue;
    }
    
    try {
      const isHealthy = await isServiceReady(meta.port, 2000);
      if (isHealthy) {
        healthResults.healthyServices++;
      } else {
        healthResults.unhealthyServices++;
        healthResults.issues.push(`Service ${serviceName} not responding on port ${meta.port}`);
        
        // Try to restart unresponsive service
        console.log(`[service-manager] Health check: restarting unresponsive service ${serviceName}`);
        try {
          child.kill('SIGTERM');
          delete childServices[serviceName];
          delete childServiceMeta[serviceName];
          
          // Free the port and return to pool
          if (portAllocations.has(serviceName)) {
            const port = portAllocations.get(serviceName);
            portAllocations.delete(serviceName);
            portPool.add(port);
          }
          
          // Allow some time for cleanup
          await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (error) {
          healthResults.issues.push(`Failed to restart service ${serviceName}: ${error.message}`);
        }
      }
    } catch (error) {
      healthResults.unhealthyServices++;
      healthResults.issues.push(`Health check failed for ${serviceName}: ${error.message}`);
    }
  }
  
  // Check for port conflicts
  const usedPorts = Array.from(portAllocations.values());
  const duplicatePorts = usedPorts.filter((port, index) => usedPorts.indexOf(port) !== index);
  if (duplicatePorts.length > 0) {
    healthResults.portConflicts = duplicatePorts.length;
    healthResults.issues.push(`Port conflicts detected: ${duplicatePorts.join(', ')}`);
  }
  
  return healthResults;
}

// Get comprehensive service status
export function getServiceStatus() {
  return {
    activeServices: Object.keys(childServices).length,
    availablePorts: portPool.size,
    allocatedPorts: portAllocations.size,
    portRange: `${portRange.min}-${portRange.max}`,
    services: Object.entries(childServices).map(([name, child]) => ({
      name,
      pid: child.pid,
      port: childServiceMeta[name]?.port || 'unknown',
      company: childServiceMeta[name]?.companyName || 'unknown',
      startTime: childServiceMeta[name]?.startTime || 'unknown',
      alive: !child.killed && child.exitCode === null
    }))
  };
}